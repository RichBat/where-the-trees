'''
The functionality will handle determining the coordinates of missing trees
within an orchard
'''
from scipy.spatial import Delaunay
from shapely.geometry import LineString
from pyproj import Transformer
import numpy as np
from utils import _get_orchard_info, _get_tree_information
import os
from sys import argv
from typing import Tuple


def _get_coords(tree_list: list):
    coord_pairs = np.array([[tree['lat'], tree['lng']]
                            for tree in tree_list])
    return coord_pairs[:, 1], coord_pairs[:, 0]


def find_missing_trees(tree_info, num_missing) -> np.ndarray:
    """
    This function will first establish baseline properties of the current
    mesh of trees and then will iterate between each candidate missing tree
    position to evaluate the impact of tree placement.

    Parameters
    ----------
    tree_info:
        This is the list of dictionaries to get the tree coordinates.
    num_missing:
        This is the number of trees currently missing.
    """
    # combined_points_lonlat = np.vstack([points_lonlat, new_points_lonlat])
    
    lon, lat = _get_coords(tree_info)
    initial_points = np.column_stack([lon, lat])
    lon0, lat0 = lon.mean(), lat.mean()

    trans, inv_trans = _get_transformer(lon0, lat0)
    x, y = trans.transform(lon, lat)

    goal_length, candidate_points = get_mean_edge_length_with_candidates(x, y, True)
    candidate_coords = _convert_metres_to_degrees(inv_trans, candidate_points)
    candidate_combo_seq = get_candidate_iterations(candidate_coords, num_missing)

    iterative_edges = []

    for k in candidate_combo_seq:
        combined_pts = np.vstack([initial_points, k])
        x, y = trans.transform(combined_pts[:, 0], combined_pts[:, 1])
        combo_edge_mean, _ = get_mean_edge_length_with_candidates(x, y)
        iterative_edges.append(abs(combo_edge_mean - goal_length))

    smallest_edge = np.argmin(np.array(iterative_edges))
    best_candidate = np.array(candidate_combo_seq[smallest_edge])

    return best_candidate


def get_candidate_iterations(candidates: np.ndarray, missing_trees: int) -> list:
    """
    This function makes unique combinations of candidate coords where the number of
    coordinates per combination is equal to missing_trees
    """
    prospect_cnt = len(candidates)
    sequences = []

    def _build_sequence(current_combo, start):
        if len(current_combo) == missing_trees:
            sequences.append(current_combo)
            return
        for i in range(start, prospect_cnt):
            _build_sequence(current_combo + [candidates[i]], i + 1)

    _build_sequence([], 0)
    return sequences


def get_mean_edge_length_with_candidates(x: np.ndarray, y: np.ndarray, initial_run: bool = False) -> Tuple[float, np.ndarray] | Tuple[float, None]:
    """
    This function will receive transformed coordinates (into metres)
    and will determine the average length of the triangle edges.
    An optional flag is provided so that the initial run will provide
    candidate missing tree locations.

    Parameters
    ----------
    x:
        The x-axis position in metres.
    y:
        The y-axis position in metres.
    intial_run: (optional)
        The flag for the initial run to also return candidate triangles
    
    """
    points_xy = np.vstack([x, y]).T

    triangles, areas = calculate_mesh(x, y)
    bad_mask = _get_bad_mask(areas, 1.7, 2.2)

    goal_length = get_average_edge_length(triangles, points_xy, bad_mask)
    
    if initial_run:
        candidate_points = _get_midpoints(points_xy, triangles, bad_mask)
        return goal_length, candidate_points
    else:
        return goal_length, None
    

def _get_transformer(lon0: float, lat0: float) -> Tuple[Transformer, Transformer]:
    """
    This function will get a transformer and inverse transformer to convert between
    coordinates in degrees to metres.

    Parameters
    ----------
    lon0:
        The mean longitude of the point coordinates to act as the longitude reference
    lat0:
        the mean latitude of the point coordinates to act as the latitude reference
    """
    proj_str = f"+proj=aeqd +lat_0={lat0} +lon_0={lon0} +units=m"
    transformer = Transformer.from_crs("EPSG:4326", proj_str, always_xy=True)
    transformer_inv = Transformer.from_crs(proj_str, "EPSG:4326", always_xy=True)
    return transformer, transformer_inv


def calculate_mesh(x: np.ndarray, y: np.ndarray) -> Tuple[Delaunay, np.ndarray]:
    """
    This function will calculate the Delaunay Triangulated mesh
    for the provided coordinate system.
    
    Parameters
    ----------
    x:
        The x-axis coordinates for the system that are in metres.
    y:
        The y-axis coordinates for the system that are in metres.

    NOTE
    Use the transformers generated by _get_transformer() to convert
    between coordinate systems before mesh calculation.
    """
    points_xy = np.vstack([x, y]).T

    tri = Delaunay(points_xy)

    def triangle_area(pts):
        A, B, C = pts
        return 0.5 * abs(
            (B[0] - A[0]) * (C[1] - A[1]) - (C[0] - A[0]) * (B[1] - A[1])
        )

    areas = np.array([
        triangle_area(points_xy[simplex])
        for simplex in tri.simplices
    ])

    return tri, areas


def _get_bad_mask(areas, lower, upper):
    """
    This function will create a mask to isolate the bad triangles
    which are candidates for missing trees. Areas within the deviation
    lower and upper bounds are defined as candidates. If a bound is
    set to None then it will not apply.

    Parameters
    ----------
    areas:
        The triangle areas.
    lower:
        The lower bound of the deviation thresholding.
    upper:
        The upper bound of the deviation thresholding.
    """
    mask = None
    deviation = areas/areas.mean()
    mask_lower = deviation > lower if lower is not None else deviation == deviation
    mask_upper = deviation < upper if upper is not None else deviation == deviation
    mask = mask_lower & mask_upper
    return mask


def get_average_edge_length(tri: Delaunay, points_xy: np.ndarray, bad_mask: np.ndarray) -> np.floating:
    """
    This function gets the average triangle edge length of all good triangles.
    The mean edge length is returned as a float
    """
    good_tris = tri.simplices[~bad_mask]
    edges = []
    for simplex in good_tris:
        pts = points_xy[simplex]
        edges += [
            (pts[0], pts[1]),
            (pts[1], pts[2]),
            (pts[2], pts[0])
        ]
    # Remove duplicate edges (by coordinates)
    lines = [LineString([tuple(A), tuple(B)]) for A, B in edges]
    unique_lines = []
    seen = set()
    for line in lines:
        coords = tuple(sorted(line.coords))
        if coords not in seen:
            seen.add(coords)
            unique_lines.append(line)

    lengths = [line.length for line in unique_lines]
    if len(lengths) == 0:
        return np.float64(0.0)
    return np.mean(lengths)


def _get_midpoints(coordinates: np.ndarray, triangles: Delaunay,
                   mask: np.ndarray) -> np.ndarray:
    """
    This function calculates the mid-point of the longest edge
    for the masked triangles. The methodology is that the candidate
    point is position along the longest bad triangle edge.

    Parameters
    ----------
    coordinates:
        The triangle coordinate system to provide the points for edge
        calculation.
    triangles:
        The triangles to be evaluated for longest edge midpoint determination
    """
    new_points = []

    for simplex, is_bad in zip(triangles.simplices, mask):
        if not is_bad:
            continue
        pts = coordinates[simplex]
        edges = [
            (pts[0], pts[1]),
            (pts[1], pts[2]),
            (pts[2], pts[0])
        ]
        lengths = [np.linalg.norm(e1 - e2) for e1, e2 in edges]
        idx_longest = np.argmax(lengths)
        A, B = edges[idx_longest]
        M = (A + B) / 2
        new_points.append(M)

    new_points = np.unique(np.array(new_points), axis=0)
    # drop duplicate coordinates as adjacent bad triangles in a region can
    # share the same midpoint.

    return new_points


def _convert_metres_to_degrees(inverse_trans: Transformer, points: np.ndarray):
    """
    This function will convert from metres back to degrees for the given points.
    """
    if len(points) > 0:
        mx, my = points.T
        mlon, mlat = inverse_trans.transform(mx, my)
        degree_coords = np.vstack([mlon, mlat]).T
        return degree_coords
    else:
        raise ValueError('There are no new points to convert.')


if __name__ == '__main__':
    orchard_id = int(argv[1])
    orchid_info = _get_orchard_info(orchard_id)
    if orchid_info['status'] == 200:
        print('Response successful')
        survey_id = orchid_info['id']
    else:
        print("token state:", os.getenv("token"))
        raise ValueError(orchid_info['status'])
    try:
        tree_info = _get_tree_information(survey_id)
    except Exception as e:
        print("Failed")
        print(survey_id)
        raise e
    
    missing_trees = find_missing_trees(tree_info['trees'], 4)
    